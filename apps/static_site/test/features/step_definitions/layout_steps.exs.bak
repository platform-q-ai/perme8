defmodule StaticSite.LayoutSteps do
  use Cucumber.StepDefinition
  use ExUnit.Case

  import ExUnit.CaptureIO

  @tmp_dir System.tmp_dir!() <> "/static_site_layout_test"

  defp setup_temp_dir do
    File.rm_rf!(@tmp_dir)
    File.mkdir_p!(@tmp_dir)
    @tmp_dir
  end

  defp cleanup_temp_dir do
    File.rm_rf!(@tmp_dir)
  end

  # --- GIVEN Steps ---

    site_path = context[:site_path]
    file_path = Path.join([site_path, "content/posts/test-post.md"])

    # Get frontmatter content from docstring
    content = context.docstring <> "\n\nPost content here."

    File.mkdir_p!(Path.dirname(file_path))
    File.write!(file_path, content)

    {:ok, context |> Map.put(:last_created_file, file_path)}
  end

  step "a layout exists at {string}", %{args: [layout_path]} = context do
    site_path = context[:site_path]
    full_path = Path.join(site_path, layout_path)

    # Create a basic HEEx layout template
    layout_content = """
    <!DOCTYPE html>
    <html>
    <head>
      <title><%= @page.title %></title>
    </head>
    <body>
      <%= @page.content %>
    </body>
    </html>
    """

    File.mkdir_p!(Path.dirname(full_path))
    File.write!(full_path, layout_content)

    {:ok, context |> Map.put(:last_layout_path, full_path)}
  end

  step "the config specifies:", context do
    site_path = context[:site_path]
    config_path = Path.join(site_path, "config/static_site.exs")

    # Get config content from docstring
    config_spec = context.docstring

    # Create config with the specified defaults
    config_content = """
    import Config

    config :static_site,
      site: %{
        title: "Test Site",
        url: "https://example.com"
      },
      #{config_spec}
    """

    File.write!(config_path, config_content)

    {:ok, context}
  end

  step "a post exists at {string} without layout specified",
       %{args: [file_path]} =
         context do
    site_path = context[:site_path]
    full_path = Path.join(site_path, file_path)

    # Create post without layout field in frontmatter
    content = """
    ---
    title: "Test Post"
    ---

    Post content.
    """

    File.mkdir_p!(Path.dirname(full_path))
    File.write!(full_path, content)

    {:ok, context |> Map.put(:last_created_file, full_path)}
  end

  step "a layout exists at {string} containing:", %{args: [layout_path]} = context do
    site_path = context[:site_path]
    full_path = Path.join(site_path, layout_path)

    # Get layout content from docstring
    layout_content = context.docstring

    File.mkdir_p!(Path.dirname(full_path))
    File.write!(full_path, layout_content)

    {:ok, context |> Map.put(:last_layout_path, full_path)}
  end

  step "a partial exists at {string}", %{args: [partial_path]} = context do
    site_path = context[:site_path]
    full_path = Path.join(site_path, partial_path)

    # Create a simple partial
    partial_content = """
    <header>
      <h1>Site Header</h1>
    </header>
    """

    File.mkdir_p!(Path.dirname(full_path))
    File.write!(full_path, partial_content)

    {:ok, context |> Map.put(:last_partial_path, full_path)}
  end

  # --- WHEN Steps ---

  step "I run {string}", %{args: [command]} = context do
    site_path = context[:site_path]

    {output, exit_code} =
      try do
        output =
          capture_io(fn ->
            File.cd!(site_path, fn ->
              # Simulate running the build command
              # In RED state, this will fail because the task doesn't exist
              raise "Mix task not implemented yet (expected RED state)"
            end)
          end)

        {output, 0}
      rescue
        error ->
          {Exception.message(error), 1}
      end

    cleanup_temp_dir()

    {:ok,
     context
     |> Map.put(:command_output, output)
     |> Map.put(:exit_code, exit_code)
     |> Map.put(:command, command)}
  end

  # --- THEN Steps ---

  step "the build should succeed", context do
    assert context[:exit_code] == 0,
           "Expected build to succeed but got exit code #{context[:exit_code]}. Output: #{context[:command_output]}"

    {:ok, context}
  end

  step "the build should fail", context do
    assert context[:exit_code] != 0,
           "Expected build to fail but it succeeded. Output: #{context[:command_output]}"

    {:ok, context}
  end

  step "the rendered HTML should use {string} layout", %{args: [layout_name]} = context do
    site_path = context[:site_path]

    # In a real implementation, we'd parse the generated HTML
    # and verify the layout was applied
    # For RED state, we'll just verify the expected output file would exist

    # This test will fail in RED state because no HTML is generated yet
    output_path = Path.join([site_path, "_site/posts/test-post.html"])

    if File.exists?(output_path) do
      html_content = File.read!(output_path)

      # Check that HTML contains structure from the layout
      assert html_content =~ "<!DOCTYPE html>",
             "Expected rendered HTML to contain layout structure"
    else
      # In RED state, file won't exist - this is expected
      # The assertion will fail, which is correct for RED state
      assert false,
             "Expected output file to exist at #{output_path} (RED state - expected failure)"
    end

    {:ok, context}
  end

  step "I should see error {string}", %{args: [error_text]} = context do
    output = context[:command_output]

    assert output =~ error_text,
           "Expected error message containing '#{error_text}', got: #{output}"

    {:ok, context}
  end

  step "the error should list available layouts", context do
    output = context[:command_output]

    # In a real implementation, error would list available layouts
    # For RED state, we'll just check that error mentions layouts
    assert output =~ "layout",
           "Expected error to mention available layouts, got: #{output}"

    {:ok, context}
  end

  step "the rendered HTML should include content from the partial", context do
    site_path = context[:site_path]

    # Check that rendered HTML includes partial content
    output_path = Path.join([site_path, "_site/posts/test-post.html"])

    if File.exists?(output_path) do
      html_content = File.read!(output_path)

      assert html_content =~ "Site Header",
             "Expected rendered HTML to include content from partial"
    else
      # In RED state, file won't exist
      assert false,
             "Expected output file to exist at #{output_path} (RED state - expected failure)"
    end

    {:ok, context}
  end
end
