defmodule StaticSite.RelativePathsTest do
  @moduledoc """
  Tests for relative path functionality added in the relative paths improvement session.

  This test suite ensures:
  1. Scaffold generates templates with correct relative paths
  2. Collection pages use relative URLs for post links  
  3. Collection pages get asset fingerprinting
  4. Index page is generated by scaffold

  These tests prevent regressions in the relative path improvements.
  """
  use ExUnit.Case, async: false

  @moduletag :relative_paths
  @test_base_dir Path.join(System.tmp_dir!(), "static_site_relative_paths_test")

  setup_all do
    # Clean up before all tests
    File.rm_rf!(@test_base_dir)
    File.mkdir_p!(@test_base_dir)

    on_exit(fn ->
      File.rm_rf!(@test_base_dir)
    end)

    :ok
  end

  describe "scaffold template relative paths" do
    setup do
      # Create unique test directory for this test
      test_id = System.unique_integer([:positive])
      tmp_dir = Path.join(@test_base_dir, "scaffold_#{test_id}")
      File.mkdir_p!(tmp_dir)

      site_name = "test_site"
      site_path = Path.join(tmp_dir, site_name)

      # Run scaffold command directly (like Cucumber tests do)
      # Change to tmp_dir so the scaffold creates the site there
      original_dir = File.cwd!()
      File.cd!(tmp_dir)

      try do
        Mix.Tasks.StaticSite.New.run([site_name])
      after
        File.cd!(original_dir)
      end

      assert File.exists?(site_path), "Site directory should be created"

      %{site_path: site_path, tmp_dir: tmp_dir}
    end

    test "scaffold creates default layout with root-level relative paths", %{site_path: site_path} do
      layout_path = Path.join([site_path, "layouts", "default.html.heex"])
      assert File.exists?(layout_path)

      content = File.read!(layout_path)

      # Should use ./css/app.css (root level)
      assert content =~ "href=\"./css/app.css\""
      assert content =~ "src=\"./js/app.js\""

      # Should link to index.html not /
      assert content =~ "href=\"index.html\""
      refute content =~ "href=\"/\""
    end

    test "scaffold creates post layout with one-level-up relative paths", %{site_path: site_path} do
      layout_path = Path.join([site_path, "layouts", "post.html.heex"])
      assert File.exists?(layout_path)

      content = File.read!(layout_path)

      # Should use ../css/app.css (one level up)
      assert content =~ "../css/app.css"
      assert content =~ "../js/app.js"

      # Navigation is handled by render_partial("nav.html") which generates
      # relative links dynamically based on page depth
      assert content =~ "render_partial(\"nav.html\""
    end

    test "scaffold creates page layout with one-level-up relative paths", %{site_path: site_path} do
      layout_path = Path.join([site_path, "layouts", "page.html.heex"])
      assert File.exists?(layout_path)

      content = File.read!(layout_path)

      # Should use ../css/app.css (one level up)
      assert content =~ "../css/app.css"
      assert content =~ "../js/app.js"

      # Navigation is handled by render_partial("nav.html") which generates
      # relative links dynamically based on page depth
      assert content =~ "render_partial(\"nav.html\""
    end

    test "scaffold creates collection layout with one-level-up relative paths", %{
      site_path: site_path
    } do
      layout_path = Path.join([site_path, "layouts", "collection.html.heex"])
      assert File.exists?(layout_path)

      content = File.read!(layout_path)

      # Should dynamically calculate base path based on URL depth
      assert content =~ "url_parts = String.split" or content =~ "base = if length(url_parts)",
             "Collection layout should calculate relative paths dynamically"

      assert content =~ "<%= base %>/css/app.css"
      assert content =~ "<%= base %>/js/app.js"
    end

    test "scaffold creates config with base_path option", %{site_path: site_path} do
      config_path = Path.join([site_path, "config", "static_site.exs"])
      assert File.exists?(config_path)

      content = File.read!(config_path)

      # Should include base_path config with documentation
      assert content =~ "base_path:"
      assert content =~ "Base path for URLs"
      assert content =~ "relative links"
      assert content =~ "subdirectory hosting"
    end

    test "scaffold creates index.md content file", %{site_path: site_path} do
      index_path = Path.join([site_path, "content", "index.md"])
      assert File.exists?(index_path)

      content = File.read!(index_path)

      # Should have frontmatter with layout
      assert content =~ "---"
      assert content =~ "title:"
      assert content =~ "layout: home"

      # Should have content
      assert content =~ "Welcome to"

      # Should use relative links
      assert content =~ "pages/about.html"

      # Should NOT use absolute paths
      refute content =~ ~r/href="\//,
             "Index should not use absolute paths"
    end

    test "scaffold creates nav partial with relative links", %{site_path: site_path} do
      nav_path = Path.join([site_path, "layouts", "partials", "nav.html"])
      assert File.exists?(nav_path)

      content = File.read!(nav_path)

      # Should use dynamic relative links based on current page depth
      # The nav uses EEx to conditionally output the right relative path
      assert content =~ "assigns[:page]" or content =~ "is_map_key(page, :url)",
             "Nav should safely check page for URL to determine path depth"

      assert content =~ "index.html",
             "Nav should link to index.html"

      assert content =~ "about.html",
             "Nav should link to about page"

      # Should NOT use absolute paths
      refute content =~ ~r/href="\//,
             "Nav should not use absolute paths starting with /"
    end
  end

  describe "integration test: full relative path workflow" do
    @describetag :integration
    @describetag timeout: 60_000

    setup do
      # Create unique test directory for this integration test
      test_id = System.unique_integer([:positive])
      tmp_dir = Path.join(@test_base_dir, "integration_#{test_id}")
      File.mkdir_p!(tmp_dir)

      site_name = "integration_site"
      site_path = Path.join(tmp_dir, site_name)

      # Create site with scaffold (like Cucumber tests do)
      original_dir = File.cwd!()
      File.cd!(tmp_dir)

      try do
        Mix.Tasks.StaticSite.New.run([site_name])
      after
        File.cd!(original_dir)
      end

      assert File.exists?(site_path), "Site directory should be created"

      # Build the site
      File.cd!(site_path)

      try do
        Mix.Tasks.StaticSite.Build.run([])
      after
        File.cd!(original_dir)
      end

      output_dir = Path.join([site_path, "_site"])
      assert File.exists?(output_dir), "Output directory should exist after build"

      %{site_path: site_path, output_dir: output_dir, tmp_dir: tmp_dir}
    end

    test "index page has root-level relative paths with fingerprinting", %{output_dir: output_dir} do
      index_html = Path.join(output_dir, "index.html") |> File.read!()

      # Should have fingerprinted assets with ./ prefix
      assert index_html =~ ~r/href="\.\/css\/app-[a-f0-9]+\.css"/,
             "Index should have fingerprinted CSS with ./ prefix"

      assert index_html =~ ~r/src="\.\/js\/app-[a-f0-9]+\.js"/,
             "Index should have fingerprinted JS with ./ prefix"

      # Should link to relative pages (nav partial uses ./index.html at root level)
      assert index_html =~ "index.html", "Index should have relative home link"
    end

    test "post pages have one-level-up relative paths with fingerprinting", %{
      output_dir: output_dir
    } do
      post_files = Path.wildcard(Path.join([output_dir, "posts", "*.html"]))
      assert length(post_files) > 0, "Should have at least one post file"

      post_html = hd(post_files) |> File.read!()

      # Should have fingerprinted assets with ../ prefix
      assert post_html =~ ~r/href="\.\.\/css\/app-[a-f0-9]+\.css"/,
             "Post should have fingerprinted CSS with ../ prefix"

      assert post_html =~ ~r/src="\.\.\/js\/app-[a-f0-9]+\.js"/,
             "Post should have fingerprinted JS with ../ prefix"

      # Should link back to home
      assert post_html =~ ~r/href="\.\.\/index\.html"/,
             "Post should have relative home link"
    end

    test "page files have one-level-up relative paths with fingerprinting", %{
      output_dir: output_dir
    } do
      page_files = Path.wildcard(Path.join([output_dir, "pages", "*.html"]))
      assert length(page_files) > 0, "Should have at least one page file"

      page_html = hd(page_files) |> File.read!()

      assert page_html =~ ~r/href="\.\.\/css\/app-[a-f0-9]+\.css"/,
             "Page should have fingerprinted CSS"

      assert page_html =~ ~r/src="\.\.\/js\/app-[a-f0-9]+\.js"/,
             "Page should have fingerprinted JS"
    end

    test "tag pages have relative paths and fingerprinting", %{output_dir: output_dir} do
      tag_files = Path.wildcard(Path.join([output_dir, "tags", "*.html"]))
      assert length(tag_files) > 0, "Should have at least one tag file"

      tag_html = hd(tag_files) |> File.read!()

      # Assets should be fingerprinted with ../
      assert tag_html =~ ~r/href="\.\.\/css\/app-[a-f0-9]+\.css"/,
             "Tag page should have fingerprinted CSS"

      assert tag_html =~ ~r/src="\.\.\/js\/app-[a-f0-9]+\.js"/,
             "Tag page should have fingerprinted JS"

      # Home link should be relative
      assert tag_html =~ ~r/href="\.\.\/index\.html"/, "Tag page should have relative home link"

      # Post links should be relative (not absolute)
      assert tag_html =~ ~r/href="\.\.\/posts\/.*\.html"/,
             "Tag page should have relative post links"

      refute tag_html =~ ~r/href="\/posts\//,
             "Tag page should not have absolute post links"
    end

    test "category pages have relative paths and fingerprinting", %{output_dir: output_dir} do
      category_files = Path.wildcard(Path.join([output_dir, "categories", "*.html"]))
      assert length(category_files) > 0, "Should have at least one category file"

      category_html = hd(category_files) |> File.read!()

      # Assets should be fingerprinted with ../
      assert category_html =~ ~r/href="\.\.\/css\/app-[a-f0-9]+\.css"/,
             "Category page should have fingerprinted CSS"

      assert category_html =~ ~r/src="\.\.\/js\/app-[a-f0-9]+\.js"/,
             "Category page should have fingerprinted JS"

      # Post links should be relative
      assert category_html =~ ~r/href="\.\.\/posts\/.*\.html"/,
             "Category page should have relative post links"
    end

    test "fingerprinted asset files exist", %{output_dir: output_dir} do
      # Should have exactly one fingerprinted CSS and JS file
      css_files = Path.wildcard(Path.join([output_dir, "css", "app-*.css"]))
      assert length(css_files) == 1, "Should have exactly one fingerprinted CSS file"

      js_files = Path.wildcard(Path.join([output_dir, "js", "app-*.js"]))
      assert length(js_files) == 1, "Should have exactly one fingerprinted JS file"
    end

    test "build produces correct number of pages, collections, and assets", %{
      output_dir: output_dir,
      site_path: site_path
    } do
      # Verify the build output structure matches expected counts:
      # Summary should show: Pages: 3, Collections: 4, Assets: 2, Files written: 10
      # Note: Collections includes the "posts" collection (posts/index.html)

      # === PAGES: 3 total ===
      # 1. index.html
      assert File.exists?(Path.join(output_dir, "index.html")),
             "Index page should exist"

      # 2. posts/{date}-welcome.html (1 post)
      post_files = Path.wildcard(Path.join([output_dir, "posts", "*.html"]))
      # Should have 2 files: the post itself AND posts/index.html
      assert length(post_files) == 2, "Should have 2 HTML files in posts/ (1 post + posts index)"

      # Verify the individual post exists (not the index)
      individual_post_files =
        Enum.filter(post_files, fn file ->
          not String.ends_with?(file, "index.html")
        end)

      assert length(individual_post_files) == 1, "Should have 1 individual post page"

      # 3. pages/about.html (1 page)
      page_files = Path.wildcard(Path.join([output_dir, "pages", "*.html"]))
      assert length(page_files) == 1, "Should have 1 page (about)"

      # === COLLECTIONS: 3 total (tags + categories, not including posts) ===
      # The welcome.md post has: tags: ["welcome", "getting-started"] and category: "general"
      # So we should have 2 tag pages + 1 category page = 3 collections

      # Tags: welcome.html, getting-started.html (2 tags)
      tag_files = Path.wildcard(Path.join([output_dir, "tags", "*.html"]))
      assert length(tag_files) == 2, "Should have 2 tag pages (welcome, getting-started)"

      # Categories: general.html (1 category)
      category_files = Path.wildcard(Path.join([output_dir, "categories", "*.html"]))
      assert length(category_files) == 1, "Should have 1 category page (general)"

      # === ASSETS: 2 total ===
      # 1. css/app-{hash}.css (1 fingerprinted CSS)
      css_files = Path.wildcard(Path.join([output_dir, "css", "app-*.css"]))
      assert length(css_files) == 1, "Should have 1 fingerprinted CSS file"

      # 2. js/app-{hash}.js (1 fingerprinted JS)
      js_files = Path.wildcard(Path.join([output_dir, "js", "app-*.js"]))
      assert length(js_files) == 1, "Should have 1 fingerprinted JS file"

      # === FILES WRITTEN: 10 total ===
      # Count all generated files:
      # - 1 index.html
      # - 1 post HTML ({date}-welcome.html)
      # - 1 posts index HTML (posts/index.html)
      # - 1 page HTML (pages/about.html)
      # - 2 tag HTMLs (tags/*.html)
      # - 1 category HTML (categories/*.html)
      # - 1 CSS file
      # - 1 JS file
      # = 9 files total
      all_html_files =
        Path.wildcard(Path.join([output_dir, "**", "*.html"]))
        |> Enum.filter(fn path -> !String.contains?(path, "~") end)

      all_asset_files =
        (Path.wildcard(Path.join([output_dir, "css", "app-*.css"])) ++
           Path.wildcard(Path.join([output_dir, "js", "app-*.js"])))
        |> Enum.filter(fn path -> !String.contains?(path, "~") end)

      total_files = length(all_html_files) + length(all_asset_files)

      assert total_files == 9,
             "Should write 9 files total (got #{total_files}). " <>
               "HTML: #{length(all_html_files)}, Assets: #{length(all_asset_files)}"

      # Verify the source content files exist
      assert File.exists?(Path.join([site_path, "content", "index.md"])),
             "Source index.md should exist"

      welcome_posts = Path.wildcard(Path.join([site_path, "content", "posts", "*-welcome.md"]))

      assert length(welcome_posts) == 1,
             "Source welcome post should exist (got #{length(welcome_posts)})"

      assert File.exists?(Path.join([site_path, "content", "pages", "about.md"])),
             "Source about page should exist"
    end
  end
end
