defmodule Documents.Api.SetupSteps do
  @moduledoc """
  Setup step definitions for Document API Access feature tests.

  These steps create document fixtures for scenarios that need pre-existing
  documents in workspaces and projects. Documents are stored in context
  keyed by the feature-file slug for slug translation in action steps.

  ## Slug Translation

  Document slugs are auto-generated by `SlugGenerator` from the title,
  so they won't match the feature-file slugs exactly (e.g., "product-spec"
  becomes "product-spec-abc123"). We store a `slug_translations` map in
  context so that action steps can translate feature-file slugs to actual
  DB slugs when constructing API paths.
  """

  use Cucumber.StepDefinition
  use JargaApi.ConnCase, async: false

  import Jarga.DocumentsFixtures

  alias JargaApi.Test.Helpers

  # ============================================================================
  # DOCUMENT SETUP STEPS
  # ============================================================================

  step "workspace {string} has a document {string} with slug {string} and content {string}",
       %{args: [workspace_slug, title, feature_slug, content]} = context do
    workspace = Helpers.get_workspace_by_slug(context, workspace_slug)

    unless workspace do
      raise "Workspace #{workspace_slug} not found in context"
    end

    owner =
      get_in(context, [:workspace_owners, workspace_slug]) ||
        context[:current_user] ||
        raise "No owner found for workspace #{workspace_slug}"

    document = document_fixture(owner, workspace, nil, %{title: title, content: content})

    {:ok, store_document(context, feature_slug, document)}
  end

  step "workspace {string} has a document {string} with slug {string}",
       %{args: [workspace_slug, title, feature_slug]} = context do
    workspace = Helpers.get_workspace_by_slug(context, workspace_slug)

    unless workspace do
      raise "Workspace #{workspace_slug} not found in context"
    end

    owner =
      get_in(context, [:workspace_owners, workspace_slug]) ||
        context[:current_user] ||
        raise "No owner found for workspace #{workspace_slug}"

    document = document_fixture(owner, workspace, nil, %{title: title})

    {:ok, store_document(context, feature_slug, document)}
  end

  step "workspace {string} has a document {string} with slug {string} owned by {string}",
       %{args: [workspace_slug, title, feature_slug, owner_email]} = context do
    workspace = Helpers.get_workspace_by_slug(context, workspace_slug)

    unless workspace do
      raise "Workspace #{workspace_slug} not found in context"
    end

    owner =
      get_in(context, [:users, owner_email]) ||
        raise "User #{owner_email} not found in context[:users]"

    document = document_fixture(owner, workspace, nil, %{title: title})

    {:ok, store_document(context, feature_slug, document)}
  end

  step "workspace {string} has a public document {string} with slug {string} owned by {string}",
       %{args: [workspace_slug, title, feature_slug, owner_email]} = context do
    workspace = Helpers.get_workspace_by_slug(context, workspace_slug)

    unless workspace do
      raise "Workspace #{workspace_slug} not found in context"
    end

    owner =
      get_in(context, [:users, owner_email]) ||
        raise "User #{owner_email} not found in context[:users]"

    document = document_fixture(owner, workspace, nil, %{title: title, is_public: true})

    {:ok, store_document(context, feature_slug, document)}
  end

  step "{string} has a private document {string} with slug {string} in workspace {string}",
       %{args: [owner_email, title, feature_slug, workspace_slug]} = context do
    workspace = Helpers.get_workspace_by_slug(context, workspace_slug)

    unless workspace do
      raise "Workspace #{workspace_slug} not found in context"
    end

    owner =
      get_in(context, [:users, owner_email]) ||
        raise "User #{owner_email} not found in context[:users]"

    # Private document: is_public = false (which is the default)
    document = document_fixture(owner, workspace, nil, %{title: title, is_public: false})

    {:ok, store_document(context, feature_slug, document)}
  end

  step "project {string} has a document {string} with slug {string} and content {string}",
       %{args: [project_name, title, feature_slug, content]} = context do
    project =
      get_in(context, [:projects, project_name]) ||
        raise "Project #{project_name} not found in context[:projects]"

    # Find workspace for this project
    workspace = find_workspace_for_project(context, project)

    owner =
      get_workspace_owner(context, workspace) ||
        context[:current_user] ||
        raise "No owner found for workspace"

    document = document_fixture(owner, workspace, project, %{title: title, content: content})

    {:ok, store_document(context, feature_slug, document)}
  end

  # ============================================================================
  # HELPERS
  # ============================================================================

  defp store_document(context, feature_slug, document) do
    documents = Map.get(context, :documents, %{})
    slug_translations = Map.get(context, :slug_translations, %{})

    context
    |> Map.put(:documents, Map.put(documents, feature_slug, document))
    |> Map.put(:slug_translations, Map.put(slug_translations, feature_slug, document.slug))
  end

  defp find_workspace_for_project(context, project) do
    all_workspaces =
      Map.values(context[:workspaces] || %{}) ++
        Map.values(context[:additional_workspaces] || %{})

    Enum.find(all_workspaces, fn w -> w.id == project.workspace_id end) ||
      raise "Workspace for project not found"
  end

  defp get_workspace_owner(context, workspace) do
    get_in(context, [:workspace_owners, workspace.slug])
  end
end
